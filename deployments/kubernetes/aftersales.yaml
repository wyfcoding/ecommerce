# aftersales.yaml - 售后微服务的 Kubernetes 部署配置

---
# Kubernetes API 版本
apiVersion: apps/v1
# 资源类型：Deployment (部署)
kind: Deployment
metadata:
  # Deployment 的名称，通常与微服务名称一致
  name: aftersales-service
  # 命名空间，根据实际环境配置，例如：ecommerce-prod, ecommerce-dev
  namespace: ecommerce
  labels:
    # 应用名称标签
    app: ecommerce
    # 微服务名称标签
    service: aftersales-service
spec:
  # 副本数量，建议生产环境至少2个，以保证高可用
  replicas: 3
  # Pod 选择器，用于 Deployment 识别和管理其 Pod
  selector:
    matchLabels:
      service: aftersales-service
  # 部署策略：RollingUpdate (滚动更新) 是生产环境推荐的策略
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # 滚动更新期间，最多可以比期望副本数多出的 Pod 数量或百分比
      maxSurge: 25%
      # 滚动更新期间，最多可以不可用的 Pod 数量或百分比
      maxUnavailable: 25%
  # Pod 模板定义
  template:
    metadata:
      labels:
        app: ecommerce
        service: aftersales-service
    spec:
      # 容器启动前拉取镜像的策略，Always (总是拉取) 确保使用最新镜像
      imagePullPolicy: Always
      # 如果使用私有镜像仓库，需要配置 imagePullSecrets
      # imagePullSecrets:
      #   - name: regcred
      # 服务账户名称，用于 Pod 访问 Kubernetes API
      # serviceAccountName: aftersales-service-sa
      # Pod 的安全上下文，推荐以非 root 用户运行，并限制权限
      securityContext:
        runAsUser: 1000 # 运行用户 ID
        runAsGroup: 1000 # 运行组 ID
        fsGroup: 1000 # 文件系统组 ID
        # 允许容器以只读根文件系统运行，增强安全性
        readOnlyRootFilesystem: true
        # 不允许提升权限
        allowPrivilegeEscalation: false
      containers:
        - name: aftersales-service
          # 镜像名称，请替换为您的实际镜像路径和标签
          image: your-docker-registry/ecommerce-aftersales-service:latest
          # 容器端口定义
          ports:
            - containerPort: 8080 # 应用程序监听的端口
              name: http
              protocol: TCP
          # 环境变量，从 ConfigMap 和 Secret 中加载
          envFrom:
            - configMapRef:
                name: aftersales-service-config # 引用 ConfigMap
            - secretRef:
                name: aftersales-service-secret # 引用 Secret
          # 资源请求和限制，非常重要，用于调度和保证服务质量
          resources:
            requests:
              cpu: "100m" # 最小 CPU 请求
              memory: "256Mi" # 最小内存请求
            limits:
              cpu: "500m" # 最大 CPU 限制
              memory: "512Mi" # 最大内存限制
          # 存活探针：用于判断容器是否存活，如果失败则重启容器
          livenessProbe:
            httpGet:
              path: /health # 健康检查路径
              port: http
            initialDelaySeconds: 30 # 容器启动后延迟30秒开始探测
            periodSeconds: 10 # 每10秒探测一次
            timeoutSeconds: 5 # 探测超时时间
            failureThreshold: 3 # 连续3次失败则认为不健康
          # 就绪探针：用于判断容器是否准备好接收流量
          readinessProbe:
            httpGet:
              path: /ready # 就绪检查路径
              port: http
            initialDelaySeconds: 15 # 容器启动后延迟15秒开始探测
            periodSeconds: 5 # 每5秒探测一次
            timeoutSeconds: 3 # 探测超时时间
            failureThreshold: 3 # 连续3次失败则认为未就绪
          # 卷挂载，用于挂载 ConfigMap 和 Secret
          volumeMounts:
            - name: aftersales-config-volume
              mountPath: /app/config/application.toml # 配置文件挂载路径
              subPath: application.toml # ConfigMap 中的具体文件
            - name: aftersales-secret-volume
              mountPath: /app/secrets # 密文挂载路径
              readOnly: true
      # 卷定义
      volumes:
        - name: aftersales-config-volume
          configMap:
            name: aftersales-service-config # 引用 ConfigMap
        - name: aftersales-secret-volume
          secret:
            secretName: aftersales-service-secret # 引用 Secret
---
# Kubernetes API 版本
apiVersion: v1
# 资源类型：Service (服务)
kind: Service
metadata:
  name: aftersales-service
  namespace: ecommerce
  labels:
    app: ecommerce
    service: aftersales-service
spec:
  # Service 类型：ClusterIP (集群内部访问)
  # 如果需要外部访问，可以考虑 LoadBalancer 或 NodePort，或者通过 Ingress 暴露
  type: ClusterIP
  # Pod 选择器，Service 将流量转发到带有这些标签的 Pod
  selector:
    service: aftersales-service
  ports:
    - protocol: TCP
      port: 80 # Service 监听的端口
      targetPort: http # 转发到 Pod 的端口 (对应容器的 name: http)
      name: http
---
# Kubernetes API 版本
apiVersion: autoscaling/v2
# 资源类型：HorizontalPodAutoscaler (HPA - 水平 Pod 自动扩缩器)
kind: HorizontalPodAutoscaler
metadata:
  name: aftersales-service-hpa
  namespace: ecommerce
  labels:
    app: ecommerce
    service: aftersales-service
spec:
  # HPA 监控的目标资源 (Deployment)
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: aftersales-service
  # 最小 Pod 副本数
  minReplicas: 3
  # 最大 Pod 副本数
  maxReplicas: 10
  # 扩缩容指标定义
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70 # 当 CPU 平均使用率达到 70% 时触发扩容
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 75 # 当内存平均使用率达到 75% 时触发扩容
---
# Kubernetes API 版本
apiVersion: v1
# 资源类型：ConfigMap (配置映射)
kind: ConfigMap
metadata:
  name: aftersales-service-config
  namespace: ecommerce
  labels:
    app: ecommerce
    service: aftersales-service
data:
  # 示例配置项，请根据实际的 aftersales.toml 内容进行填充
  # 建议将 configs/aftersales.toml 的内容直接复制到这里
  application.toml: |
    # 数据库配置
    database.host = "aftersales-db-host"
    database.port = 5432
    database.name = "aftersales_db"
    database.user = "aftersales_service_user"
    # database.password = "请使用 Secret 管理密码"

    # 服务端口
    server.port = 8080

    # 日志级别
    logging.level = "INFO"

    # 其他业务配置...
    feature.toggle.new_feature = true
---
# Kubernetes API 版本
apiVersion: v1
# 资源类型：Secret (密文)
kind: Secret
metadata:
  name: aftersales-service-secret
  namespace: ecommerce
  labels:
    app: ecommerce
    service: aftersales-service
# Secret 类型，Opaque (不透明) 是通用类型
type: Opaque
stringData:
  # 示例敏感信息，请替换为实际的敏感数据
  # 数据库密码
  DATABASE_PASSWORD: "your_aftersales_db_password"
  # 外部服务 API 密钥
  EXTERNAL_API_KEY: "your_external_api_key"
  # JWT 签名密钥
  JWT_SIGNING_KEY: "your_jwt_signing_key"